# Lab 7: Multithreading 

---
### 实验目标

本次实验旨在通过实现一个用户态线程库，了解和掌握线程上下文切换、多线程并发执行以及同步机制的实现。具体目标包括：

1. 实现一个简单的用户态线程库，支持线程的创建、切换和调度。
2. 使用多线程加速程序，并解决多线程环境中的竞态问题。
3. 实现一个同步屏障，确保多个线程按顺序协同工作。

### 用户态线程的实现

#### 1. 线程上下文切换的实现
在用户态实现的线程库中，我们需要自己管理线程的上下文切换。在本实验中，我们使用了一个 `context` 结构体来保存线程的状态信息，包含 `ra`（返回地址）和 `sp`（栈指针），以及 `s0` 到 `s11` 的寄存器值，这些都是在上下文切换时需要保存的内容。

在 `uthread_switch.S` 文件中，我们实现了上下文切换的汇编代码。该函数的主要工作是保存当前线程的上下文，并将新线程的上下文加载到 CPU 寄存器中。具体代码如下：

```assembly
/* 保存当前线程的寄存器并恢复新线程的寄存器 */
thread_switch:
    sd ra, 0(a0)
    sd sp, 8(a0)
    sd s0, 16(a0)
    sd s1, 24(a0)
    sd s2, 32(a0)
    sd s3, 40(a0)
    sd s4, 48(a0)
    sd s5, 56(a0)
    sd s6, 64(a0)
    sd s7, 72(a0)
    sd s8, 80(a0)
    sd s9, 88(a0)
    sd s10, 96(a0)
    sd s11, 104(a0)

    ld ra, 0(a1)
    ld sp, 8(a1)
    ld s0, 16(a1)
    ld s1, 24(a1)
    ld s2, 32(a1)
    ld s3, 40(a1)
    ld s4, 48(a1)
    ld s5, 56(a1)
    ld s6, 64(a1)
    ld s7, 72(a1)
    ld s8, 80(a1)
    ld s9, 88(a1)
    ld s10, 96(a1)
    ld s11, 104(a1)

    ret    /* 返回到 ra */
```

该代码的核心是保存当前线程的寄存器状态，并恢复新线程的寄存器。`thread_switch` 函数的输入参数为当前线程和下一线程的上下文地址。

#### 2. 线程创建与调度
在 `uthread.c` 中，我们为每个线程分配了一个栈和一个 `context` 结构体。线程的创建过程包括分配线程栈、设置栈指针和返回地址等。当一个线程被创建时，我们将其状态设为 `RUNNABLE`，并设置线程的 `ra` 寄存器为线程函数的地址，`sp` 寄存器为线程栈的顶端。

线程调度通过 `thread_schedule()` 函数实现。在该函数中，线程调度器遍历所有线程并选择下一个可运行的线程。如果当前线程与下一个线程不同，我们就进行上下文切换，调用 `thread_switch()` 来保存当前线程的上下文并恢复下一个线程的上下文。

```c
void thread_schedule(void)
{
    // ...... (寻找下一个线程)
    if (current_thread != next_thread) {  /* 切换线程 */
        next_thread->state = RUNNING;
        t = current_thread;
        current_thread = next_thread;
        thread_switch(&t->ctx, &next_thread->ctx);  // 切换上下文
    }
}
```

#### 3. 多线程加速实现与竞态条件问题
实验要求通过多线程加速程序，但在并发执行时可能会遇到竞态条件（race condition）。在一个哈希表操作的例子中，我们观察到了两个线程并发修改相同桶时，导致数据丢失的问题。具体来说，两个线程分别尝试设置键 `k1` 和 `k2`，由于没有正确的同步机制，它们可能会在操作过程中覆盖对方的修改，导致 `k2` 被丢失。

在此问题的解决方案中，我们首先为整个哈希表加上了一个全局锁（`pthread_mutex_t lock`）。这样，在同一时刻只能有一个线程操作哈希表。这个解决方案虽然能够解决竞态条件问题，但由于锁的开销，它使得多线程版本的性能甚至低于单线程版本。

为了解决这个问题，我们将锁粒度从整个哈希表改为每个桶一个锁，这样多个线程可以同时操作不同的桶，从而提高并发度和性能。修改后的代码如下：

```c
pthread_mutex_t locks[NBUCKET];

void put(int key, int value)
{
    int i = key % NBUCKET;
    pthread_mutex_lock(&locks[i]);

    // 插入操作

    pthread_mutex_unlock(&locks[i]);
}
```

这样，我们就避免了全局锁带来的性能瓶颈，同时确保了线程安全。

### 同步屏障的实现

#### 1. 屏障的原理
同步屏障是一种常见的多线程同步机制，确保所有线程在执行到某个同步点时，都会在此处等待，直到所有线程都到达该点后才会继续执行。在实验中，我们实现了一个简单的屏障，通过条件变量和互斥锁来同步线程。

在 `barrier()` 函数中，线程首先增加已到达屏障的线程数量。如果该数量尚未达到总线程数，则线程将进入睡眠状态，等待其他线程。最后一个到达的线程会广播通知所有等待的线程继续执行。

```c
static void barrier()
{
    pthread_mutex_lock(&bstate.barrier_mutex);
    if (++bstate.nthread < nthread) {
        pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);
    } else {
        bstate.nthread = 0;
        bstate.round++;
        pthread_cond_broadcast(&bstate.barrier_cond);
    }
    pthread_mutex_unlock(&bstate.barrier_mutex);
}
```

通过这种方式，我们能够实现一个有效的同步屏障，确保所有线程在特定位置同步，从而保证正确的并行执行。

### 结果与分析

在实验过程中，我们通过多个线程实现了哈希表操作，并成功解决了竞态条件问题。通过降低锁粒度，我们在确保线程安全的同时，也有效提升了程序的性能。同步屏障部分则通过条件变量和互斥锁的组合，保证了多线程在特定同步点的协作。

通过在实验中实现的这些线程同步机制，我们不仅学习了如何在用户态实现线程库，还掌握了多线程并发执行中的问题和解决方法。最终，我们成功实现了一个能够正确运行的用户态线程库，并使用它解决了哈希表操作中的竞态问题以及实现了同步屏障。
